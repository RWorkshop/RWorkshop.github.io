
<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="RWorkshop.GitHub.io : Website">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>RWorkshop.GitHub.io</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          
          <h1 id="project_title">RWorkshop.GitHub.io</h1>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h5>



      </section>
    
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:11px 15px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:11px 15px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}
.tg .tg-b44r{background-color:#cbcefb;vertical-align:top}
.tg .tg-yw4l{vertical-align:top}
.tg .tg-76so{font-size:15px;background-color:#cbcefb;vertical-align:top}
</style>
<center>
<table class="tg" style="undefined;table-layout: fixed; width: 900px">
<colgroup>
<col style="width: 900px">

</colgroup>

  <tr>
    <td class="tg-76so"><strong><a href="caret/index.html">The caret Package</a></strong><br><br>
<h4>Vectors<h4>

The primary data type in R is the vector. Before describing how vectors work in R, it is helpful to distinguish two ideas of vectors in order to set the correct expectations.



A vector in \texttt{R} is a container vector, a statistician's collection of data, not a mathematical vector. The \texttt{R} language is designed around the assumption that a vector is an ordered set of measurements rather than a geometrical position or a physical state. (\texttt{R} supports mathematical vector operations, but they are secondary in the design of the language.) This helps explain, for example, \texttt{R}'s otherwise inexplicable vector recycling feature.

Adding a vector of length 22 and a vector of length 45 in most languages would raise an exception; the language designers would assume the programmer has made an error and the program is now in an undefined state. However, \texttt{R} allows adding two vectors regardless of their relative lengths.

\subsubsection{Recycling}
 The elements of the shorter summand are recycled as often as necessary to create a vector the length of the longer summand. This is not attempting to add physical vectors that are incompatible for addition, but rather a syntactic convenience for manipulating sets of data. (\texttt{R} does issue a warning when adding vectors of different lengths and the length of the longer vector is not an integer multiple of the length of the shorter vector. So, for example, adding vectors of lengths 3 and 7 would cause a warning, but adding vectors of length 3 and 6 would not.)

The \texttt{R}  language has no provision for scalars, nothing like a double in C-family languages. The only way to represent a single number in a variable is to use a vector of length one. And while it is possible to iterate through vectors as one might do in a for loop in C, it is usually clearer and more efficient in \texttt{R} to operate on vectors as a whole.

<h4>Creating Vectors</h4>
Vectors are created using the c function. For example, \texttt{p <- c(2,3,5,7)} sets p to the vector containing the first four prime numbers.
\begin{framed}
\begin{verbatim}
p <- c(2,3,5,7)
\end{verbatim}
\end{framed}
%Vectors in R are indexed starting with 1 and matrices in are stored in column-major order. In both of these ways R resembles FORTRAN.

<ul>
<li> Elements of a vector can be accessed using the square bracket operators []. So in the above example, \texttt{p[3]} is 5.
<li>  Vectors automatically expand when assigning to an index past the end of the vector.
<li>  Negative indices are legal, but they have a very different meaning than in some other languages. If x is an array in Python or Perl, x[-n] returns the nth element from the end of the vector. In \texttt{R}, x[-n] returns a copy of x with the nth element removed.
 </ul>

\begin{framed}
\begin{verbatim}
p <- c(2,3,5,7)
p[2]
p[-2]
\end{verbatim}
\end{framed}

\begin{verbatim}
> p <- c(2,3,5,7)
> p
[1] 2 3 5 7
> p[2]
[1] 3
> p[-2]
[1] 2 5 7
\end{verbatim}

 <h4>Vectors</h4>
 Vectors are the simplest type of object in R. There are 3 main types of vectors:
<ul>
<li> Numeric vectors
<li> Character vectors
<li> Logical vectors
</ul>
To set up a numeric vector x consisting of 7 numbers; {10, 5, 3, 6, 21,11,41}, we use the \texttt{c()} command to “concatenate” them –i.e create a vector of individual values.
To print the contents of x, simply type “x”

\begin{framed}
\begin{verbatim}
x <- c(10, 5, 3, 6, 21,11,41) 
\end{verbatim}
\end{framed}
\begin{verbatim}
> x <- c(10, 5, 3, 6, 21,11,41) 
> x 
[1] 10 5 3 6 21 11 41
\end{verbatim}

The [1] in front of the result is the index of the first element in the vector x. (The single value variables from earlier on are simply vectors containing one element).
To access a particular element of a vector, and the position of the element enclosed in square brackets.

\textbf{(End of Edit - Move to Reserve - Vectors)}
<h4>Useful Commands For Vectors</h4>

\begin{verbatim}
Newvec = c(13,16,36,55,23,11)
\end{verbatim}
\begin{itemize}
\item \texttt{sort(Newvec)}  -  sort data set in ascending order
\item \texttt{rev(Newvec) } -  reverse the data set order
\item \texttt{rep(Newvec,n)}  -  replicate the data set $n$ times
\item \texttt{rep(Newvec,each=n)} - replicate each element of the data set $n-$times
\item \texttt{diff(Newvec)} - sequential difference of each element
\item \texttt{order(Newvec)}
\item \texttt{rank(Newvec)}
\end{itemize}


\begin{verbatim}
> Newvec = c(13,16,36,55,23,11)
>
> sort(Newvec)
[1] 11 13 16 23 36 55
> rev(Newvec)
[1] 11 23 55 36 16 13
>
> rep(Newvec,2)
 [1] 13 16 36 55 23 11 13 16 36 55 23 11
> rep(Newvec,3)
 [1] 13 16 36 55 23 11 13 16 36 55 23 11 13 16 36 55 23 11
>
> rep(Newvec,each=3)
 [1] 13 13 13 16 16 16 36 36 36 55 55 55 23 23 23 11 11 11
> diff(Newvec)
[1]   3  20  19 -32 -12
> order(Newvec)
[1] 6 1 2 5 3 4
>
> rank(Newvec)
[1] 2 3 5 6 4 1
\end{verbatim}

     <h4>Sequences</h4>
\subsubsection{Using the colon operator}
A `count-up' or a `count-down' sequence of integers will be determined automatically. This operator is very useful and we will make use of it frequently.
\begin{framed}
\begin{verbatim}
1:20
20:1
10:20
\end{verbatim}
\end{framed}
\subsubsection{Using the \texttt{seq()} operator}
Firstly we will mimic the sequences that we have created using the colon operator.
\begin{verbatim}
seq(1,20)
seq(20,1)
\end{verbatim}



    </tr>

</table>
</center>

<!--#########################################################-->

\subsection{Vectors}
<ul>
<li> $R$ operates on named data structures. The simplest such
structure is the vector, which is a single entity consisting of an
ordered collection of numbers or characters.

<li> The most common types of vectors are:
<ul>
<li> Numeric vectors <li> Character vectors <li> Logical
vectors
</ul>

<li> There are, of course, other types of vectors.
<ul>
<li> Colour vectors - potentially useful later on.
<li> Order vectors - The rankings of items in a vector.
<li> Complex number vectors - not part of this course.
</ul>
</ul>

<!--#########################################################-->
\subsection{Vectors: Creating and editing a vector}
<ul>
<li> From last class.
<li> To create a vector, use the assignment operator ``$=$" or ( $<-$ )and
the concatenate function ``c()". <li> For numeric vectors, the values
entered are simply numbers.

<code>
>x =c(10.4,5.6,3.1,6.4,8.9)
>
<\code>

And, from last week, we can use the ``data.entry()" function to edit our vector.
<code>
>data.entry(x)
>
<\code>
</ul>




<!--#########################################################-->
\subsection{Vectors: Character \& logical vector}

<ul>
<li> For character vectors, the values are simply characters,
specified with quotation marks.
<li> Single quotation marks
<code>

>Charvec<-c(`Dog', `Cat', `Shed', `Spoon')

<\code>

<li> A logical vectors is a vector whose elements are TRUE, FALSE
or NA (i.e. null)
<code>

>Logvec<-c(TRUE, FALSE,TRUE,TRUE )

<\code>

</ul>

<!--#########################################################-->
\subsection{Graphical Data Entry Interface}
<ul>

<li> The data.entry() command calls a spreadsheet graphical user
interface, which can be used to edit data. All changes are saved
automatically.




<li> Alternatively, the edit() command calls the `R editor',
which can be used to edit specified data or the code used to
define that data.

<code>
x<-edit(x)
<\code>

</ul>



<!--#########################################################-->

\subsection{Vectors: Empty vectors}

<ul>
<li> Another method of creating vectors is to use the follow

<ul>
<li> numeric (length = n) <li> character (length = n) <li>
logical (length = n)</ul>

<li> These commands create empty vectors, of the appropriate
kind, of length n.

<code>
> x<-numeric(4)
> x
[1] 0 0 0 0
<\code>

<li> You can use the graphical data entry interface to populate
your data sets.
</ul>


<!--#########################################################-->
\subsection{Vectors: Characteristics}

<ul>
<li> We can use several $R$ commands to gather information about
a vector.

<ul>
<li> length(x) - how many elements in a vector.  <li> sum(x)-
the sum of the elements in a vector. <li> prod(x) - the product
of the elements in a vector.
</ul>

<li> We can also find statistical information about a vector
<ul>
<li> summary(x) - summary statistics of a vector.  <li> mean(x)-
the mean value of a vector. <li> sd(x) -  the standard deviation
of a vector.
</ul>

<li> Refer to the reference card for more commands to try out.
</ul>

<!--#########################################################-->
\subsection{Vectors: Characteristics (contd)}

<code>
> mean(x)
[1] 6.375
> sd(y)
[1] 2.858846
> median(z)
[1] 16
> summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  3.100   4.975   6.000   6.375   7.400  10.400
<\code>


<!--#########################################################-->
\subsection{Calculations using vectors}

<ul>
<li> Calculations are performed on a vector on a case-wise basis.
The calculations are carried out on each element individually.
<code>
> y^2
[1]  2.56 12.25 60.84 44.89 65.61
<\code>

</ul>
<ul>
<li> Try the following calculations.
<code>
> y*z
[1]  25.6  31.5 280.8  26.8 202.5
> sum(z)
[1] 90
> sum(y^2)
[1] 186.15
> sum(y*z)
[1] 567.2
<\code>
</ul>

<!--#########################################################-->
\subsection{Accessing vector's elements}

<ul>
<li> The $n$th element of vector `x' can be accessed by
specifying its index when calling `x'.
<code>
>x[3]
[1] 3.1
<\code>

<li> A sequence of  elements of vector `x' can be accessed by
specifying the lower and upper bound of the the range, in form
x[l:u].
<code>
> x[2:4]
<\code>
</ul>



<!--#########################################################-->

\subsection{Modifying a vector}

<ul>
<li> A vector can be updated by assigning an extra value to it.
<code>
> logvec<-c(logvec,TRUE)
> logvec
[1]  TRUE FALSE  TRUE  TRUE  TRUE
<\code>

<li> A vector can be repeated $n$ times using the rep() command.
<code>
> rep(charvec,2)
[1] "blue" "pink" "red" "blue" "pink" "red"
<\code>

<li> Omitting and deleting the $n$th element of vector `x'.
<code>
>charvec[-5]
>charvec <- charvec[-5]
<\code>

</ul>

<!--#########################################################-->
\subsection{Relational operators}
A relational operator tests some kind of relation between two
entities. For $R$ the relational operators are as follows:
\begin{center}
\begin{tabular}{|c|c|c|c|}
  \hline

  Equals & == & Less or equal to  & <= \\
  \hline
  Not Equal & != & Greater than & > \\
  \hline
  Less than & < & Greater than & >= \\
  \hline
\end{tabular}
\end{center}

<!--#########################################################-->
\subsection{Logical operators}
<ul>
<li> The logical operators are AND, OR and NOT

<li> if c1 and c2 are logical expressions, then $c1 \& c2$ is
their intersection (`AND'), $c1 | c2$ is their union (`OR'), and
$!c1$ is the negation of c1.
</ul>
\begin{center}
\begin{tabular}{|c|c|c|c|}
  \hline
  AND & $ \& $ & also  & $\&\&$ \\
  \hline
  OR & $|$ & also & $||$ \\
  \hline
  NOT & $!$ & &  \\
  \hline
\end{tabular}
\end{center}

<!--#########################################################-->
\subsection{Examples using operators}

We can use relational and logical operators to selecting elements
of a vector with specified criteria.

<code>
#selecting all elements of x greater than 5
>x[x>5]

#selecting all elements of x greater or equal to than 5
>x[x>=5]

#selecting all elements of x greater than 5 #or less than 3
>x[(x>5)|(x<3)]

#selecting all elements of x between 3 and 5
>x[(x>3)&(x<5)]
<\code>


<!--#########################################################-->
\end{document}


    </div>
    
    
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">

    </div>

    

  </body>
</html>
















