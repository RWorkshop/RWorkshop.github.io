

<h2>Matrix}
Matrices are essentially a subset of arrays, and behave in a virtually identical manner. The two important
differences are:

<ul>
<li> Matrices always have 2 dimensions
<li> Matrices follow the rules of linear algebra for Matrix Multiplication ($\ast$)
</ul>

<pre>
<code>
>>> x = [0.0, 1, 2, 3, 4] # Any float makes all float
>>> y = array(x)
>>> type(y)
numpy.ndarray
>>> y * y # Elementbyelement
array([ 0., 1., 4., 9., 16.])
>>> z = asmatrix(x)
>>> type(z)
numpy.matrixlib.defmatrix.matrix
>>> z * z # Error
ValueError: matrices are not aligned
</code>
</pre>
\newpage
<h2>1-dimensional Arrays}
%4.3 - ALL good so far
A vector
\[x = [1 2 3 4 5]\]
is entered as a 1-dimensional array using
<pre>
<code>
>>> x=array([1.0,2.0,3.0,4.0,5.0])
array([ 1., 2., 3., 4., 5.])
>>> ndim(x)
1
</code>
</pre>
%----------------------%
If an array with 2-dimensions is required, it is necessary to use a trivial nested list.
<pre>
<code>
>>> x=array([[1.0,2.0,3.0,4.0,5.0]])
array([[ 1., 2., 3., 4., 5.]])
>>> ndim(x)
2
</code>
</pre>

A matrix is always 2-dimensional and so a nested list is not required to initialize a a row matrix
<pre>
<code>
>>> x=matrix([1.0,2.0,3.0,4.0,5.0])
>>> x
matrix([[ 1., 2., 3., 4., 5.]])
>>> ndim(x)
2
</code>
</pre>
Notice that the output matrix representation uses nested lists ([[ ]]) to emphasize the 2-dimensional
structure of all matrices. The column vector,
\[x =
\left[ 
\begin{array}{c}
1 \\
2 \\
3 \\
4 \\
5
\end{array}
\right]
\]
is entered as a matrix or 2-dimensional array using a set of nested lists
<pre>
<code>
>>> x=matrix([[1.0],[2.0],[3.0],[4.0],[5.0]])
>>> x
matrix([[ 1.],
[ 2.],
[ 3.],
[ 4.],
[ 5.]])
>>> x = array([[1.0],[2.0],[3.0],[4.0],[5.0]])
>>> x
array([[ 1.],
[ 2.],
[ 3.],
[ 4.],
[ 5.]])
</code>
</pre>
\newpage
%=======================================%




%-------------------------------------------------------------------------%

\newpage
% KS 4.4 2-dimensional Arrays
% GOOD
<h2>2-dimensional Arrays}
Matrices and 2-dimensional arrays are rows of columns, and so
\[x =
\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 \\
\end{array}
\]
is input by enter the matrix one row at a time, each in a list, and then encapsulate the row lists in another
list.
<pre>
<code>
>>> x = array([[1.0,2.0,3.0],[4.0,5.0,6.0],[7.0,8.0,9.0]])
>>> x
array([[ 1., 2., 3.],
[ 4., 5., 6.],
[ 7., 8., 9.]])
</code>
</pre>

%---------------------------------------------%
% KS - 4.5 Multidimensional Arrays
% GOOD
\newpage
<h2>Multidimensional Arrays}
<ul>
<li> Higher dimensional arrays are useful when tracking matrix valued processes through time, such as a time varying
covariance matrices. 
<li> Multidimensional (N -dimensional) arrays are available for N up to about 30,
<li> depending on the size of each matrix dimension. 
<li> Manually initializing higher dimension arrays is tedious
and error prone, and so it is better to use functions such as \texttt{zeros((2, 2, 2))} or \texttt{empty((2, 2, 2))}.
</ul>
%---------------------------------------------%

%<h2>Concatenation}
% KS -  4.6 Concatenation
% Lots to add in
% Concatenation is the process by which one vector or matrix is appended to another. Arrays and matrices
% can be concatenation horizontally or vertically
%---------------------------------------------%
% KS 4.7 Accessing Elements of an Array
<h2>Accessing Elements of an Array }


% Numerical indexing and logical indexing both depends on specialized functions and
% so these methods are discussed in Chapter 12

<ul>
<li> Four methods are available for accessing elements contained within an array: scalar selection, slicing,
numerical indexing and logical (or Boolean) indexing. 
<li> Scalar selection and slicing are the simplest and so
are presented first. 
%<li> Numerical indexing and logical indexing both depends on specialized functions and
%so these methods are discussed in Chapter 12.
</ul>

% KS - 4.9 import and Modules

<h2>The \texttt{import} function}
<ul>
<li> Python, by default, only has access to a small number of built-in types and functions. The vast majority of
functions are located in modules, and before a function can be accessed, the module which contains the
function must be imported. 

<li> For example, when using \texttt{ipython --pylab} (or any variants), a large number
of modules are automatically imported, including NumPy and matplotlib.
<li> This is style of importing useful
for learning and interactive use, but care is needed to make sure that the correct module is imported when
designing more complex programs.

<li> \texttt{import} can be used in a variety of ways. The simplest is to use from module \texttt{import *} which imports
all functions in module. 
<li> This method of using import can dangerous since if you use it more than once,
it is possible for functions to be hidden by later imports. 
<li> A better method is to just import the required
functions. 
<li> This still places functions at the top level of the namespace, but can be used to avoid conflicts.
<pre>
<code>
from pylab import log2 # Will import log2 only
from scipy import log10 # Will not import the log2 from SciPy
</code>
</pre>
%KS page 59
<li> The only difference between these two is that \texttt{import scipy} is implicitly calling \texttt{import scipy as scipy}.
<li> When this formof import is used, functions are used with the “as” name. For example, the load provided
by NumPy is accessed using \texttt{sp.log2}, while the pylab load is \texttt{pl.log2} – and both can be used where appropriate.
<li> While this method is the most general, it does require slightly more typing.
</ul>
%--------------------------------------------------------------------------------------------%
